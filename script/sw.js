var e;!function(e){e[e.RegVerifying=0]="RegVerifying",e[e.RegRegistering=1]="RegRegistering",e[e.RegWaiting=2]="RegWaiting",e[e.RegUnregistering=3]="RegUnregistering",e[e.RegVerified=4]="RegVerified",e[e.RegRegistered=5]="RegRegistered",e[e.RegUnregistered=6]="RegUnregistered",e[e.RegDeclined=7]="RegDeclined",e[e.RegDiscarded=8]="RegDiscarded",e[e.HttpFailure=9]="HttpFailure",e[e.HttpError=10]="HttpError"}(e||(e={}));const t=self;var a=!1;function r(e){return e instanceof Error?e.message:"string"==typeof e?e:"Unknown error"}function n(e){return new Promise(t=>setTimeout(t,e))}async function s(e){const a=await t.clients.matchAll();for(const t of a)t.postMessage(e)}let i="AppDB",o=1,c=null,l=0;function p(){return l++,new Promise((e,t)=>{if(c)e(c);else{let a=indexedDB.open(i,o);a.onerror=e=>{let a=r(e);t(new Error("AppDB Error: "+a))},a.onblocked=()=>{t(new Error("AppDB Failure: The application database is blocked"))},a.onsuccess=t=>{let a=t.target;c=a.result,e(c)}}})}function u(){l--,l<1&&(l=0,c&&(c.close(),c=null))}function y(e){return new Promise((t,a)=>{e.onsuccess=a=>{a.target instanceof IDBRequest?(e=a.target,t(e.result)):t(void 0)},e.onerror=e=>{a(e)}})}class d extends Error{attempts;constructor(e){super(`The poll was canceled after ${e} attempts`),this.attempts=e,this.name="PollingCancelledError"}}class g{_url;_options;_requestOptions;_attempts=0;_isCancelled=!1;constructor(e,t={},a){this._url=e,this._options={interval:5e3,...t},this._requestOptions={headers:{"Content-Type":"application/json",Accept:"application/json",...a.headers},...a}}async makeRequest(){const e=await fetch(this._url,this._requestOptions);if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);return await e.json()??null}cancel(){this._isCancelled=!0}getAttemptCount(){return this._attempts}async poll(){for(;!this._isCancelled;){this._attempts++,this._options.onAttempt&&this._options.onAttempt(this._attempts);try{var e=await this.makeRequest();if(this._options.validateResponse&&(null===e||this._options.validateResponse(e)||(e=null)),null!==e)return e}catch(e){const t=e instanceof Error?e:new Error(String(e));console.error(`Error on attempt ${this._attempts}:`,t.message),this._options.onError&&this._options.onError(t)}if(this._isCancelled)break;await n(this._options.interval)}throw new d(this._attempts)}}async function h(){return await async function(e){let t;try{let a=(await p()).transaction(e,"readonly").objectStore(e);t=await y(a.get("credential"))}finally{return u(),t}}("_system")}async function w(e){return async function(e,t){try{let a=(await p()).transaction(e,"readwrite").objectStore(e);await y(a.put(t,"credential"))}finally{u()}}("_system",e)}async function f(){return async function(e){try{(await p()).transaction(e,"readwrite").objectStore(e).delete("credential")}finally{u()}}("_system")}async function R(t,a){const r=new g(t,{interval:7e3,validateResponse:e=>!e.email&&!e.cryptoKeyValue||!!e.email&&!!e.cryptoKeyValue},{method:"GET",mode:"cors",headers:{Authorization:a.apiKey,Accept:"application/json","Content-Type":"application/json"}});let n;const s=await r.poll();if("string"==typeof s.cryptoKeyValue){if(a.anchor!==s.email)throw await f(),new Error(`Inconsistent user's details: "${a.anchor}" & "${s.email}" is not equal!`);a.cryptoKey=s.cryptoKeyValue,await w(a),n={type:e.RegRegistered,credential:a,unregAgentInfo:s.deletedApiKeyInfo}}else await f(),n={type:e.RegDeclined,message:null};return n}t.addEventListener("message",async t=>{if(!a){const n=t.data;switch(n.type){case"INIT":console.log("[SW] INIT received !!!"),i=n.databaseName,o=n.databaseVersion;break;case"VERIFICATION":a=!0,s({type:e.RegVerifying}),await async function(t){let a;try{const r=await h();switch(!0){case"object"==typeof r&&!!r?.cryptoKey:const n={method:"GET",mode:"cors",headers:{Authorization:r.apiKey}},i=await fetch(t.verificationRequest,n);if(i.ok)a={type:e.RegVerified,credential:r};else switch(i.status){case 401:case 403:a={type:e.RegDiscarded,message:null},await f();break;default:a={type:e.HttpError,credential:await h(),message:`Server error. Response status: ${i.status}.`}}break;case"object"==typeof r:s({type:e.RegWaiting,anchor:r.anchor}),a=await R(t.cryptoKeyRequest,r);break;default:r&&await f(),a={type:e.RegVerified,credential:null}}}catch(t){a={type:e.HttpError,credential:await h(),message:r(t)}}s(a)}(n),a=!1;break;case"REGISTRATION":a=!0,s({type:e.RegRegistering,anchor:n.anchor}),await async function(t){const a={email:t.anchor,apiKeyValue:void 0};try{const r=await fetch(t.apiKeyRequest,{method:"POST",headers:{"Content-Type":"application/json"},body:JSON.stringify(a)});switch(r.status){case 200:{const a=await r.json();if(!function(e){if("object"!=typeof e||null===e)return!1;const t=Object.hasOwn(e,"email")&&"string"==typeof e.email,a=Object.hasOwn(e,"apiKeyValue")&&"string"==typeof e.apiKeyValue;return t&&a}(a))throw new Error(`Inconsistent response data! (request: ${t.apiKeyRequest})`);let n={anchor:a.email,apiKey:a.apiKeyValue,cryptoKey:void 0};await w(n),s({type:e.RegWaiting,anchor:n.anchor}),s(await R(t.cryptoKeyRequest,n))}break;case 403:s({type:e.HttpFailure,status:r.status,credential:await h()});break;default:throw new Error(`HTTP error! status: ${r.status}`)}}catch(t){s({type:e.HttpError,credential:await h(),message:r(t)})}}(n),a=!1;break;case"UNREGISTRATION":a=!0,s({type:e.RegUnregistering,anchor:n.anchor}),await async function(t){try{const a=await fetch(t.unregRequest,{method:"DELETE",headers:{Authorization:t.apiKey}});switch(a.status){case 200:await f(),s({type:e.RegUnregistered,anchor:t.anchor});break;case 401:case 403:await f(),s({type:e.HttpFailure,status:a.status,credential:await h()});break;default:throw new Error(`HTTP error! status: ${a.status}`)}}catch(t){s({type:e.HttpError,credential:await h(),message:r(t)})}}(n),a=!1}}});