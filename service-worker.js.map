{"version":3,"file":"service-worker.js","mappings":"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","sources":["webpack://blazorsw-opus/webpack/bootstrap","webpack://blazorsw-opus/webpack/runtime/make namespace object","webpack://blazorsw-opus/./Scripts/service-worker/service-worker.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/**\r\n * service-worker.ts — Кастомный Service Worker для Blazor PWA\r\n *\r\n * Основные обязанности:\r\n *  1. Выполнение HTTP-запросов к серверу по команде от клиентов (вкладок).\r\n *  2. Рассылка полученных данных всем открытым клиентам (broadcast).\r\n *  3. Отклонение повторных запросов, если предыдущий ещё выполняется (busy-guard).\r\n *\r\n * Архитектурное решение: Service Worker НЕ выстраивает запросы в очередь —\r\n * если он занят, входящая команда FETCH_DATA немедленно отклоняется\r\n * с ответом FETCH_REJECTED.\r\n *\r\n * ВАЖНО: TypeScript не содержит встроенной типизации ServiceWorkerGlobalScope.\r\n * Для корректной работы в контексте SW мы:\r\n *   1. Определяем минимальный интерфейс ServiceWorkerGlobalScope.\r\n *   2. Приводим `self` к этому интерфейсу.\r\n *   3. Используем типизированные вызовы через этот интерфейс.\r\n */\r\n\r\nexport { }; // Изолируем файл как отдельный модуль для избежания конфликта TS2451\r\n\r\n// ── Типизация Service Worker ──────────────────────────────────────────\r\n// Минимальная типизация SW Global Scope — определяем только то, что используем.\r\n\r\ninterface SWClients {\r\n    claim(): Promise<void>;\r\n    matchAll(options?: { type?: string; includeUncontrolled?: boolean }): Promise<SWClient[]>;\r\n}\r\n\r\ninterface SWClient {\r\n    postMessage(message: unknown): void;\r\n}\r\n\r\ninterface SWGlobalScope {\r\n    skipWaiting(): Promise<void>;\r\n    clients: SWClients;\r\n    addEventListener(type: string, listener: (event: any) => void): void;  // eslint-disable-line @typescript-eslint/no-explicit-any\r\n}\r\n\r\n// Приводим `self` к нашему интерфейсу.\r\n// В контексте Service Worker `self` реально является ServiceWorkerGlobalScope.\r\nconst sw: SWGlobalScope = self as unknown as SWGlobalScope;\r\n\r\n// ── Типы сообщений ────────────────────────────────────────────────────\r\n\r\n/** Входящее сообщение от клиента (sw-agent.ts → SW) */\r\ninterface SwIncomingMessage {\r\n    type: \"FETCH_DATA\";\r\n    url: string;\r\n}\r\n\r\n/** Исходящее сообщение от SW ко всем клиентам */\r\ninterface SwOutgoingMessage {\r\n    type: \"DATA_RECEIVED\" | \"FETCH_REJECTED\" | \"FETCH_ERROR\";\r\n    payload?: unknown;\r\n    error?: string;\r\n}\r\n\r\n// ── Состояние занятости ───────────────────────────────────────────────\r\n// Флаг isBusy гарантирует, что одновременно выполняется\r\n// не более одного запроса к серверу.\r\nlet isBusy = false;\r\n\r\n// ── Lifecycle: install ────────────────────────────────────────────────\r\n// skipWaiting() активирует нового SW немедленно, не дожидаясь\r\n// закрытия всех вкладок со старым SW.\r\nsw.addEventListener(\"install\", () => {\r\n    console.log(\"[SW] Installing...\");\r\n    sw.skipWaiting();\r\n});\r\n\r\n// ── Lifecycle: activate ───────────────────────────────────────────────\r\n// clients.claim() перехватывает контроль над всеми уже открытыми\r\n// вкладками без перезагрузки страницы.\r\nsw.addEventListener(\"activate\", () => {\r\n    console.log(\"[SW] Activated. Claiming clients...\");\r\n    sw.clients.claim();\r\n});\r\n\r\n// ── Message handler ───────────────────────────────────────────────────\r\n// Обрабатывает команды от клиентов (sw-agent.ts).\r\n// event.data содержит объект SwIncomingMessage от sw-agent.ts.\r\nsw.addEventListener(\"message\", (event: { data: SwIncomingMessage; waitUntil?: (p: Promise<void>) => void }) => {\r\n    const data = event.data;\r\n\r\n    if (data.type === \"FETCH_DATA\") {\r\n        // Если SW уже выполняет запрос — немедленно отклоняем.\r\n        // Это ключевое архитектурное требование: запросы НЕ ставятся в очередь.\r\n        if (isBusy) {\r\n            console.warn(\"[SW] Busy — rejecting FETCH_DATA request.\");\r\n            broadcastMessage({ type: \"FETCH_REJECTED\" });\r\n            return;\r\n        }\r\n\r\n        // Запускаем fetch. Используем waitUntil если доступен,\r\n        // чтобы SW не был остановлен браузером до завершения операции.\r\n        const promise = fetchDataFromServer(data.url);\r\n        if (event.waitUntil) {\r\n            event.waitUntil(promise);\r\n        }\r\n    }\r\n});\r\n\r\n// ── Fetch logic ───────────────────────────────────────────────────────\r\n/**\r\n * Выполняет HTTP GET запрос к серверу, при успехе рассылает данные\r\n * всем клиентам. При ошибке рассылает сообщение об ошибке.\r\n *\r\n * @param url — URL для выполнения GET-запроса.\r\n */\r\nasync function fetchDataFromServer(url: string): Promise<void> {\r\n    isBusy = true;\r\n    console.log(`[SW] Fetching data from: ${url}`);\r\n\r\n    try {\r\n        const response = await fetch(url, {\r\n            method: \"GET\",\r\n            headers: { \"Accept\": \"application/json\" },\r\n            // Обходим HTTP-кэш браузера — всегда идём на сервер:\r\n            cache: \"no-cache\",\r\n        });\r\n\r\n        if (!response.ok) {\r\n            throw new Error(`HTTP ${response.status}: ${response.statusText}`);\r\n        }\r\n\r\n        const payload: unknown = await response.json();\r\n\r\n        // Успешный результат — рассылаем всем вкладкам:\r\n        await broadcastMessage({ type: \"DATA_RECEIVED\", payload });\r\n        console.log(\"[SW] Data fetched and broadcasted successfully.\");\r\n    } catch (error) {\r\n        const message = error instanceof Error ? error.message : String(error);\r\n        console.error(\"[SW] Fetch error:\", message);\r\n        await broadcastMessage({ type: \"FETCH_ERROR\", error: message });\r\n    } finally {\r\n        // Снимаем флаг занятости ПОСЛЕ broadcast'а,\r\n        // чтобы следующий запрос гарантированно видел актуальное состояние.\r\n        isBusy = false;\r\n    }\r\n}\r\n\r\n// ── Broadcast helper ──────────────────────────────────────────────────\r\n/**\r\n * Отправляет сообщение ВСЕМ открытым клиентам (вкладкам) данного SW.\r\n * Использует clients.matchAll() для обнаружения всех контролируемых клиентов.\r\n *\r\n * @param message — объект сообщения для отправки.\r\n */\r\nasync function broadcastMessage(message: SwOutgoingMessage): Promise<void> {\r\n    const allClients = await sw.clients.matchAll({\r\n        type: \"window\",\r\n        includeUncontrolled: true, // Включаем вкладки, ещё не перехваченные SW\r\n    });\r\n\r\n    for (const client of allClients) {\r\n        client.postMessage(message);\r\n    }\r\n}\r\n\r\n// ── Fetch event (pass-through) ────────────────────────────────────────\r\n// В режиме разработки (development) не перехватываем сетевые запросы —\r\n// все запросы проходят напрямую к серверу.\r\nsw.addEventListener(\"fetch\", () => {\r\n    // Намеренно пустой — pass-through к сети.\r\n    // В production-сборке (service-worker.published.ts) здесь реализуется\r\n    // стратегия кэширования Blazor-ресурсов.\r\n});\r\n"],"names":[],"sourceRoot":""}